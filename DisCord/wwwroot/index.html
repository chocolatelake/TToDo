<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TToDo Kanban</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div id="app" class="app-container">
        <header>
            <div class="header-left">
                <h1>TToDo Board</h1>
            </div>

            <div class="header-controls">
                <button class="btn-sort" @click="showFilterMenu = !showFilterMenu">🔍 絞り込み</button>

                <span class="divider">|</span>

                <button v-if="userId" class="btn-sort" @click="openBatchChannelModal">📡 送信先一括</button>
                <button class="btn-sort" @click="openAssigneeManager">👥 名寄せ</button>

                <span class="sort-label">順序:</span>
                <button class="btn-sort" :class="{active: sortMode==='priority'}" @click="sortMode='priority'">🔥</button>
                <button class="btn-sort" :class="{active: sortMode==='category'}" @click="sortMode='category'">🏷️</button>
            </div>
        </header>

        <div v-if="showFilterMenu" class="filter-panel">
            <div class="filter-section">
                <span class="filter-title">ユーザー:</span>
                <button class="chip" :class="{selected: myUserId && filterUsers.includes(myUserId)}" @click="toggleMe" v-if="myUserId">自分 (Me)</button>
                <button v-for="u in uniqueUsers" :key="u" class="chip" :class="{selected: filterUsers.includes(u)}" @click="toggleFilterUser(u)">
                    {{ u }}
                </button>
                <button class="chip" @click="filterUsers = []" v-if="filterUsers.length > 0">クリア</button>
            </div>
            <div class="filter-section">
                <span class="filter-title">チャンネル:</span>
                <button v-for="c in uniqueChannels" :key="c" class="chip" :class="{selected: filterChannels.includes(c)}" @click="toggleFilterChannel(c)">
                    {{ c }}
                </button>
                <button class="chip" @click="filterChannels = []" v-if="filterChannels.length > 0">クリア</button>
            </div>
        </div>

        <div v-if="loading" style="text-align:center">Loading...</div>

        <div v-else class="kanban-board">
            <div class="column col-todo" @dragover.prevent @drop="onDrop($event, 'active')">
                <div class="column-header">🚀 進行中 <span class="count">{{ tasksActive.length }}</span></div>
                <div class="task-container">
                    <div v-for="task in tasksActive" :key="task.id" class="card p-border" :class="getPrioClass(task)"
                         draggable="true" @dragstart="onDragStart($event, task)" @click="openEdit(task)">
                        <div class="card-header">
                            <img v-if="task.avatarUrl" :src="task.avatarUrl" class="user-avatar" :title="task.userName">
                            <span v-else class="user-badge">{{ task.userName }}</span>
                            <span v-if="task.assignee && task.assignee !== task.userName" class="assignee-badge">➡️ {{ task.assignee }}</span>
                        </div>
                        <div class="task-content">
                            <div class="tags">
                                <span class="tag server-tag" v-if="task.guildName">🏢 {{ task.guildName }}</span>
                                <span class="tag channel-tag" v-if="task.channelName"># {{ task.channelName }}</span>
                                <span v-for="tag in task.tags" class="tag">#{{ tag }}</span>
                                <span v-if="task.priority > -1" class="tag prio-tag">{{ getPrioLabel(task) }}</span>
                            </div>
                            <div class="text">{{ task.content }}</div>
                        </div>
                        <div class="actions">
                            <button class="btn-icon btn-check" @click.stop="moveToDone(task)">✔</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="column col-done" @dragover.prevent @drop="onDrop($event, 'done')">
                <div class="column-header">✅ 完了 <span class="count">{{ tasksDone.length }}</span></div>
                <div class="task-container">
                    <div v-for="task in tasksDone" :key="task.id" class="card done-card"
                         draggable="true" @dragstart="onDragStart($event, task)" @click="openEdit(task)">
                        <div class="card-header">
                            <img v-if="task.avatarUrl" :src="task.avatarUrl" class="user-avatar" :title="task.userName">
                            <span v-else class="user-badge">{{ task.userName }}</span>
                            <span v-if="task.assignee && task.assignee !== task.userName" class="assignee-badge">➡️ {{ task.assignee }}</span>
                        </div>
                        <div class="task-content">
                            <div class="tags">
                                <span class="tag time-tag">{{ formatTime(task.completedAt) }}</span>
                                <span class="tag server-tag" v-if="task.guildName">🏢 {{ task.guildName }}</span>
                                <span class="tag channel-tag" v-if="task.channelName"># {{ task.channelName }}</span>
                            </div>
                            <div class="text">{{ task.content }}</div>
                        </div>
                        <div class="actions">
                            <button class="btn-icon btn-return" @click.stop="moveToActive(task)">↩️</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="column col-archive" @dragover.prevent @drop="onDrop($event, 'archive')">
                <div class="column-header">🗑️ アーカイブ <span class="count">{{ tasksArchive.length }}</span></div>
                <div class="task-container">
                    <div v-for="task in tasksArchive" :key="task.id" class="card archive-card"
                         draggable="true" @dragstart="onDragStart($event, task)" @click="openEdit(task)">
                        <div class="task-content">
                            <div class="text">{{ task.content }}</div>
                        </div>
                        <div class="actions">
                            <button class="btn-icon btn-restore" @click.stop="moveToActive(task)">♻️</button>
                            <button class="btn-icon btn-delete" @click.stop="deleteTask(task)">💥</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div v-if="editingTask" class="modal-overlay" @click.self="editingTask = null">
            <div class="modal">
                <h3>タスク編集</h3>
                <div class="form-group"><label>内容</label><textarea class="form-control" rows="3" v-model="editForm.content"></textarea></div>
                <div class="form-group">
                    <label>担当者 (Assignee)</label>
                    <input type="text" class="form-control" v-model="editForm.assignee" list="assigneeList" placeholder="名前">
                    <datalist id="assigneeList"><option v-for="name in allAssignees" :value="name"></option></datalist>
                </div>
                <div class="form-group">
                    <label>送信先 (サーバー / チャンネル)</label>
                    <div class="row">
                        <input type="text" class="form-control" v-model="editForm.guildName" placeholder="サーバー">
                        <span style="align-self:center">/</span>
                        <input type="text" class="form-control" v-model="editForm.channelName" placeholder="チャンネル">
                    </div>
                </div>
                <div class="form-group"><label>タグ</label><input type="text" class="form-control" v-model="editForm.tagsStr"></div>
                <div class="form-group">
                    <label>優先度</label>
                    <div class="chip-group">
                        <div class="chip" :class="{selected: editForm.priority===1}" @click="editForm.priority=1">重要</div>
                        <div class="chip" :class="{selected: editForm.priority===0}" @click="editForm.priority=0">普通</div>
                        <div class="chip" :class="{selected: editForm.priority===-1}" @click="editForm.priority=-1">なし</div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button class="btn btn-cancel" @click="editingTask = null">キャンセル</button>
                    <button class="btn btn-save" @click="saveEdit">保存</button>
                </div>
            </div>
        </div>

        <div v-if="showBatchModal" class="modal-overlay" @click.self="showBatchModal = false">
            <div class="modal" style="max-width: 450px;">
                <h3>📡 送信先の一括変更</h3>
                <p style="font-size:0.9rem; color:#555;">あなたの<b>「アーカイブ以外の全タスク（完了・未完了）」</b>の日報送信先を、以下に変更します。</p>
                <div class="form-group"><label>サーバー名</label><input type="text" class="form-control" v-model="batchForm.guildName"></div>
                <div class="form-group"><label>チャンネル名</label><input type="text" class="form-control" v-model="batchForm.channelName"></div>
                <div style="font-size:0.8rem; color:#e00; margin-bottom:15px;" v-if="batchError">{{ batchError }}</div>
                <div class="modal-actions">
                    <button class="btn btn-cancel" @click="showBatchModal = false">キャンセル</button>
                    <button class="btn btn-save" @click="submitBatchChannel">一括適用</button>
                </div>
            </div>
        </div>

        <div v-if="showAssigneeManager" class="modal-overlay" @click.self="showAssigneeManager = false">
            <div class="modal" style="max-width: 600px;">
                <h3>👥 名寄せ設定</h3>
                <div class="assignee-list-editor">
                    <div v-for="(group, idx) in assigneeGroups" :key="idx" class="group-row">
                        <input type="text" v-model="group.mainName" placeholder="正式名称" class="form-control main-name">
                        <span class="arrow">⬅️</span>
                        <input type="text" v-model="group.aliasesStr" placeholder="呼び名 (カンマ区切り)" class="form-control aliases">
                        <button class="btn-icon-small" @click="assigneeGroups.splice(idx, 1)">🗑️</button>
                    </div>
                    <button class="btn-add-group" @click="assigneeGroups.push({mainName:'', aliases:[], aliasesStr:''})">＋ グループ追加</button>
                </div>
                <div class="modal-actions">
                    <button class="btn btn-cancel" @click="showAssigneeManager = false">閉じる</button>
                    <button class="btn btn-save" @click="saveAssigneeGroups">保存</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue
        createApp({
            data() {
                return {
                    tasks: [], loading: true, editingTask: null, editForm: {}, sortMode: 'priority', userId: null, myUserId: null,
                    showAssigneeManager: false, assigneeGroups: [],
                    showBatchModal: false, batchForm: { guildName: '', channelName: '' }, batchError: '',
                    showFilterMenu: false, filterUsers: [], filterChannels: []
                }
            },
            computed: {
                allAssignees() {
                    const fromTasks = this.tasks.map(t => t.assignee).filter(n => n);
                    const fromGroups = this.assigneeGroups.map(g => g.mainName).filter(n => n);
                    return [...new Set([...fromTasks, ...fromGroups])].sort();
                },
                uniqueUsers() { return [...new Set(this.tasks.map(t => t.userName).filter(n => n))].sort(); },
                uniqueChannels() { return [...new Set(this.tasks.map(t => t.guildName + ' / ' + t.channelName).filter(n => n.length > 3))].sort(); },

                filteredTasks() {
                    return this.tasks.filter(t => {
                        if (this.filterUsers.length > 0 && !this.filterUsers.includes(t.userName)) return false;
                        if (this.filterChannels.length > 0) {
                            const key = t.guildName + ' / ' + t.channelName;
                            if (!this.filterChannels.includes(key)) return false;
                        }
                        return true;
                    });
                },
                tasksActive() { return this.applySort(this.filteredTasks.filter(t => !t.isForgotten && !t.completedAt)); },
                tasksDone() {
                    const list = this.filteredTasks.filter(t => !t.isForgotten && t.completedAt);
                    return this.sortMode === 'priority' ? list.sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt)) : this.applySort(list);
                },
                tasksArchive() { return this.filteredTasks.filter(t => t.isForgotten); }
            },
            mounted() {
                const p = new URLSearchParams(window.location.search);
                const uid = p.get('uid');

                // 自分IDを保存 (フィルター用)
                if (uid) {
                    this.myUserId = uid;
                    localStorage.setItem('ttodo_uid', uid);
                    window.history.replaceState({}, '', window.location.pathname);
                } else {
                    this.myUserId = localStorage.getItem('ttodo_uid');
                }

                // 常に全件取得モードで動作
                this.userId = this.myUserId; // API操作用(Batch等)
                this.fetchTasks();
                setInterval(this.fetchTasks, 3000);
            },
            methods: {
                async fetchTasks() {
                    if (this.editingTask || this.showAssigneeManager || this.showBatchModal) return;
                    try { const r = await fetch('/api/tasks'); this.tasks = await r.json(); this.loading = false; } catch { }
                },

                toggleFilterUser(u) {
                    if (this.filterUsers.includes(u)) this.filterUsers = this.filterUsers.filter(x => x !== u);
                    else this.filterUsers.push(u);
                },
                toggleFilterChannel(c) {
                    if (this.filterChannels.includes(c)) this.filterChannels = this.filterChannels.filter(x => x !== c);
                    else this.filterChannels.push(c);
                },
                toggleMe() {
                    if (!this.myUserId) return;
                    // 自分の名前(UserName)を探す必要があるが、IDしか持っていない。
                    // タスクから自分のIDに一致するUserNameを探す
                    const myTask = this.tasks.find(t => t.userId == this.myUserId);
                    if (myTask) {
                        const myName = myTask.userName;
                        this.toggleFilterUser(myName);
                    } else {
                        alert("まだタスクがないため、自分を特定できません");
                    }
                },

                openBatchChannelModal() {
                    const lastTask = this.tasksActive.length > 0 ? this.tasksActive[0] : null;
                    this.batchForm = { guildName: lastTask ? lastTask.guildName : '', channelName: lastTask ? lastTask.channelName : '' };
                    this.batchError = ''; this.showBatchModal = true;
                },
                async submitBatchChannel() {
                    if (!this.batchForm.guildName || !this.batchForm.channelName) { this.batchError = '入力してください'; return; }
                    try {
                        const payload = { ...this.batchForm, userId: this.myUserId }; // 自分のIDを送る
                        await fetch('/api/batch/channel', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                        this.showBatchModal = false; alert('変更しました'); this.fetchTasks();
                    } catch (e) { this.batchError = 'エラー'; }
                },
                async openAssigneeManager() {
                    const r = await fetch('/api/assignees'); const data = await r.json();
                    this.assigneeGroups = data.map(g => ({ ...g, aliasesStr: g.aliases.join(', ') }));
                    this.showAssigneeManager = true;
                },
                async saveAssigneeGroups() {
                    const payload = this.assigneeGroups.filter(g => g.mainName).map(g => ({ mainName: g.mainName, aliases: g.aliasesStr.split(',').map(s => s.trim()).filter(s => s) }));
                    await fetch('/api/assignees/update', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    this.showAssigneeManager = false; this.fetchTasks();
                },
                openEdit(task) { this.editingTask = task; this.editForm = { ...task, tagsStr: task.tags.join(', ') }; },
                async saveEdit() { const p = { ...this.editForm, tags: this.editForm.tagsStr.split(',').map(s => s.trim()).filter(s => s) }; await this.post('/api/update', p); this.editingTask = null; },
                onDragStart(evt, t) { evt.dataTransfer.dropEffect = 'move'; evt.dataTransfer.effectAllowed = 'move'; evt.dataTransfer.setData('taskId', t.id); },
                onDrop(evt, s) { const id = evt.dataTransfer.getData('taskId'); const t = this.tasks.find(x => x.id === id); if (t) { if (s === 'active') this.moveToActive(t); else if (s === 'done') this.moveToDone(t); else this.moveToArchive(t); } },
                async moveToDone(t) { if (t.isForgotten) await this.post('/api/restore', t); if (!t.completedAt) { t.completedAt = new Date().toISOString(); await this.post('/api/done', t); } },
                async moveToActive(t) { if (t.isForgotten) await this.post('/api/restore', t); if (t.completedAt) { t.completedAt = null; await this.post('/api/done', t); } },
                async moveToArchive(t) { if (!t.isForgotten) { t.isForgotten = true; await this.post('/api/archive', t); } },
                async deleteTask(t) { if (confirm('完全削除しますか？')) await this.post('/api/delete', t); },
                async post(u, d) { await fetch(u, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(d) }); this.fetchTasks(); },
                applySort(l) { if (this.sortMode === 'category') { return l.sort((a, b) => ((a.tags[0] || 'z').localeCompare(b.tags[0] || 'z')) || (this.getScore(b) - this.getScore(a))); } return l.sort((a, b) => this.getScore(b) - this.getScore(a)); },
                getScore(t) { return (t.priority === 1 ? 10 : t.priority === 0 ? 5 : 1); },
                getPrioLabel(t) { return t.priority === 1 ? '重要' : (t.priority === 0 ? '普通' : ''); },
                getPrioClass(t) { return t.priority === 1 ? (t.difficulty === 1 ? 'p-1' : 'p-2') : (t.priority === 0 ? (t.difficulty === 1 ? 'p-3' : 'p-4') : 'p-0'); },
                formatTime(iso) { if (!iso) return ''; const d = new Date(iso); return d.getHours().toString().padStart(2, '0') + ':' + d.getMinutes().toString().padStart(2, '0'); }
            }
        }).mount('#app')
    </script>
</body>
</html>